{
  "README.html": {
    "href": "README.html",
    "title": "RateLimiter - Interview Challenge | RateLimiter Library Documentation",
    "summary": "RateLimiter - Interview Challenge A minimal C# project structure for implementing rate limiting algorithms. Getting Started dotnet restore dotnet build dotnet test dotnet run --project RateLimiter.ConsoleApp Your Task Implement different rate limiting algorithms: Token Bucket - Allow bursts up to a capacity, refill at steady rate Fixed Window - Simple counter that resets at fixed intervals Sliding Window - More accurate tracking over time windows Discussion Points Algorithm trade-offs (memory vs accuracy) Thread safety considerations Distributed systems challenges Testing strategies Performance characteristics Start with the IRateLimiter interface and implement your chosen algorithm!"
  },
  "api/RateLimiter.Adapters.IRateLimiterAdapter.html": {
    "href": "api/RateLimiter.Adapters.IRateLimiterAdapter.html",
    "title": "Interface IRateLimiterAdapter | RateLimiter Library Documentation",
    "summary": "Interface IRateLimiterAdapter Adapter interface for bridging between different rate limiter implementations. This allows legacy code to work with new strategy implementations. Inherited Members IRateLimiter.TryConsumeAsync(int, CancellationToken) IRateLimiter.GetAvailablePermitsAsync(CancellationToken) IRateLimiter.GetWaitTimeAsync(int, CancellationToken) IRateLimiter.ResetAsync(CancellationToken) Namespace: RateLimiter.Adapters Assembly: RateLimiter.dll Syntax public interface IRateLimiterAdapter : IRateLimiter Properties | Edit this page View Source StrategyTypeName Gets the underlying strategy type name Declaration string StrategyTypeName { get; } Property Value Type Description string Methods | Edit this page View Source GetDebugInfo() Gets additional debugging information specific to the implementation Declaration object GetDebugInfo() Returns Type Description object | Edit this page View Source SetStrategy(IRateLimiter) Sets a new underlying strategy (for runtime switching) Declaration void SetStrategy(IRateLimiter strategy) Parameters Type Name Description IRateLimiter strategy The new strategy to use"
  },
  "api/RateLimiter.Adapters.TokenBucketAdapter.html": {
    "href": "api/RateLimiter.Adapters.TokenBucketAdapter.html",
    "title": "Class TokenBucketAdapter | RateLimiter Library Documentation",
    "summary": "Class TokenBucketAdapter Adapter that bridges the legacy TokenBucket interface with the new TokenBucketStrategy implementation. This ensures backward compatibility while allowing access to new features. Inheritance object TokenBucketAdapter Implements IRateLimiterAdapter IRateLimiter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Adapters Assembly: RateLimiter.dll Syntax public class TokenBucketAdapter : IRateLimiterAdapter, IRateLimiter Constructors | Edit this page View Source TokenBucketAdapter(IOptions<RateLimiterOptions>) Declaration public TokenBucketAdapter(IOptions<RateLimiterOptions> options) Parameters Type Name Description IOptions<RateLimiterOptions> options | Edit this page View Source TokenBucketAdapter(int, double) Declaration public TokenBucketAdapter(int capacity, double refillRate) Parameters Type Name Description int capacity double refillRate Properties | Edit this page View Source CurrentTokens Legacy property access for backward compatibility Declaration public double CurrentTokens { get; } Property Value Type Description double | Edit this page View Source StrategyTypeName Gets the underlying strategy type name Declaration public string StrategyTypeName { get; } Property Value Type Description string Methods | Edit this page View Source GetAvailablePermitsAsync(CancellationToken) Gets the current number of available permits Declaration public Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task<int> Number of available permits | Edit this page View Source GetDebugInfo() Gets additional debugging information specific to the implementation Declaration public object GetDebugInfo() Returns Type Description object | Edit this page View Source GetWaitTimeAsync(int, CancellationToken) Gets the time to wait before the next permit becomes available Declaration public Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits needed CancellationToken cancellationToken Cancellation token Returns Type Description Task<TimeSpan> Time to wait, or TimeSpan.Zero if permits are available now | Edit this page View Source ResetAsync(CancellationToken) Resets the rate limiter state Declaration public Task ResetAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task | Edit this page View Source SetStrategy(IRateLimiter) Sets a new underlying strategy (for runtime switching) Declaration public void SetStrategy(IRateLimiter strategy) Parameters Type Name Description IRateLimiter strategy The new strategy to use | Edit this page View Source TryConsumeAsync(int, CancellationToken) Attempts to consume the specified number of permits Declaration public Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits to consume (default: 1) CancellationToken cancellationToken Cancellation token Returns Type Description Task<bool> True if permits were consumed, false if rate limit exceeded Implements IRateLimiterAdapter IRateLimiter"
  },
  "api/RateLimiter.Adapters.UniversalRateLimiterAdapter.html": {
    "href": "api/RateLimiter.Adapters.UniversalRateLimiterAdapter.html",
    "title": "Class UniversalRateLimiterAdapter | RateLimiter Library Documentation",
    "summary": "Class UniversalRateLimiterAdapter Universal adapter that can work with any rate limiting strategy. This provides a consistent interface for testing and legacy code integration. Inheritance object UniversalRateLimiterAdapter Implements IRateLimiterAdapter IRateLimiter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Adapters Assembly: RateLimiter.dll Syntax public class UniversalRateLimiterAdapter : IRateLimiterAdapter, IRateLimiter Constructors | Edit this page View Source UniversalRateLimiterAdapter(IRateLimiter) Declaration public UniversalRateLimiterAdapter(IRateLimiter initialStrategy) Parameters Type Name Description IRateLimiter initialStrategy Properties | Edit this page View Source StrategyTypeName Gets the underlying strategy type name Declaration public string StrategyTypeName { get; } Property Value Type Description string Methods | Edit this page View Source GetAvailablePermitsAsync(CancellationToken) Gets the current number of available permits Declaration public Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task<int> Number of available permits | Edit this page View Source GetDebugInfo() Gets additional debugging information specific to the implementation Declaration public object GetDebugInfo() Returns Type Description object | Edit this page View Source GetWaitTimeAsync(int, CancellationToken) Gets the time to wait before the next permit becomes available Declaration public Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits needed CancellationToken cancellationToken Cancellation token Returns Type Description Task<TimeSpan> Time to wait, or TimeSpan.Zero if permits are available now | Edit this page View Source ResetAsync(CancellationToken) Resets the rate limiter state Declaration public Task ResetAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task | Edit this page View Source SetStrategy(IRateLimiter) Sets a new underlying strategy (for runtime switching) Declaration public void SetStrategy(IRateLimiter strategy) Parameters Type Name Description IRateLimiter strategy The new strategy to use | Edit this page View Source TryConsumeAsync(int, CancellationToken) Attempts to consume the specified number of permits Declaration public Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits to consume (default: 1) CancellationToken cancellationToken Cancellation token Returns Type Description Task<bool> True if permits were consumed, false if rate limit exceeded Implements IRateLimiterAdapter IRateLimiter"
  },
  "api/RateLimiter.Adapters.html": {
    "href": "api/RateLimiter.Adapters.html",
    "title": "Namespace RateLimiter.Adapters | RateLimiter Library Documentation",
    "summary": "Namespace RateLimiter.Adapters Classes TokenBucketAdapter Adapter that bridges the legacy TokenBucket interface with the new TokenBucketStrategy implementation. This ensures backward compatibility while allowing access to new features. UniversalRateLimiterAdapter Universal adapter that can work with any rate limiting strategy. This provides a consistent interface for testing and legacy code integration. Interfaces IRateLimiterAdapter Adapter interface for bridging between different rate limiter implementations. This allows legacy code to work with new strategy implementations."
  },
  "api/RateLimiter.Configuration.FixedWindowOptions.html": {
    "href": "api/RateLimiter.Configuration.FixedWindowOptions.html",
    "title": "Class FixedWindowOptions | RateLimiter Library Documentation",
    "summary": "Class FixedWindowOptions Fixed window specific configuration Inheritance object FixedWindowOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Configuration Assembly: RateLimiter.dll Syntax public class FixedWindowOptions Properties | Edit this page View Source MaxRequests Maximum number of requests per window Declaration public int MaxRequests { get; set; } Property Value Type Description int | Edit this page View Source WindowSizeInSeconds Window duration in seconds Declaration public int WindowSizeInSeconds { get; set; } Property Value Type Description int"
  },
  "api/RateLimiter.Configuration.RateLimiterOptions.html": {
    "href": "api/RateLimiter.Configuration.RateLimiterOptions.html",
    "title": "Class RateLimiterOptions | RateLimiter Library Documentation",
    "summary": "Class RateLimiterOptions Configuration options for rate limiters Inheritance object RateLimiterOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Configuration Assembly: RateLimiter.dll Syntax public class RateLimiterOptions Fields | Edit this page View Source SectionName Declaration public const string SectionName = \"RateLimiter\" Field Value Type Description string Properties | Edit this page View Source FixedWindow Fixed window configuration Declaration public FixedWindowOptions FixedWindow { get; set; } Property Value Type Description FixedWindowOptions | Edit this page View Source SlidingWindow Sliding window configuration Declaration public SlidingWindowOptions SlidingWindow { get; set; } Property Value Type Description SlidingWindowOptions | Edit this page View Source TokenBucket Token bucket configuration Declaration public TokenBucketOptions TokenBucket { get; set; } Property Value Type Description TokenBucketOptions"
  },
  "api/RateLimiter.Configuration.SlidingWindowOptions.html": {
    "href": "api/RateLimiter.Configuration.SlidingWindowOptions.html",
    "title": "Class SlidingWindowOptions | RateLimiter Library Documentation",
    "summary": "Class SlidingWindowOptions Sliding window specific configuration Inheritance object SlidingWindowOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Configuration Assembly: RateLimiter.dll Syntax public class SlidingWindowOptions Properties | Edit this page View Source MaxRequests Maximum number of requests in the sliding window Declaration public int MaxRequests { get; set; } Property Value Type Description int | Edit this page View Source SubWindows Number of sub-windows for sliding calculation Declaration public int SubWindows { get; set; } Property Value Type Description int | Edit this page View Source WindowSizeInSeconds Window duration in seconds Declaration public int WindowSizeInSeconds { get; set; } Property Value Type Description int"
  },
  "api/RateLimiter.Configuration.TokenBucketOptions.html": {
    "href": "api/RateLimiter.Configuration.TokenBucketOptions.html",
    "title": "Class TokenBucketOptions | RateLimiter Library Documentation",
    "summary": "Class TokenBucketOptions Token bucket specific configuration Inheritance object TokenBucketOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Configuration Assembly: RateLimiter.dll Syntax public class TokenBucketOptions Properties | Edit this page View Source Capacity Maximum number of tokens the bucket can hold Declaration public int Capacity { get; set; } Property Value Type Description int | Edit this page View Source RefillRate Rate at which tokens are refilled per second Declaration public double RefillRate { get; set; } Property Value Type Description double"
  },
  "api/RateLimiter.Configuration.html": {
    "href": "api/RateLimiter.Configuration.html",
    "title": "Namespace RateLimiter.Configuration | RateLimiter Library Documentation",
    "summary": "Namespace RateLimiter.Configuration Classes FixedWindowOptions Fixed window specific configuration RateLimiterOptions Configuration options for rate limiters SlidingWindowOptions Sliding window specific configuration TokenBucketOptions Token bucket specific configuration"
  },
  "api/RateLimiter.Extensions.ServiceCollectionExtensions.html": {
    "href": "api/RateLimiter.Extensions.ServiceCollectionExtensions.html",
    "title": "Class ServiceCollectionExtensions | RateLimiter Library Documentation",
    "summary": "Class ServiceCollectionExtensions Extension methods for setting up rate limiter services in DI container. Inheritance object ServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Extensions Assembly: RateLimiter.dll Syntax public static class ServiceCollectionExtensions Methods | Edit this page View Source AddRateLimiter(IServiceCollection, IConfiguration) Adds rate limiter services to the dependency injection container. Declaration public static IServiceCollection AddRateLimiter(this IServiceCollection services, IConfiguration configuration) Parameters Type Name Description IServiceCollection services The service collection IConfiguration configuration The configuration section containing rate limiter options Returns Type Description IServiceCollection The service collection for chaining | Edit this page View Source AddRateLimiter(IServiceCollection, IConfiguration, RateLimiterStrategyType) Adds rate limiter services with a specific strategy as the default. Declaration public static IServiceCollection AddRateLimiter(this IServiceCollection services, IConfiguration configuration, RateLimiterStrategyType defaultStrategy) Parameters Type Name Description IServiceCollection services The service collection IConfiguration configuration The configuration section containing rate limiter options RateLimiterStrategyType defaultStrategy The default strategy type to use Returns Type Description IServiceCollection The service collection for chaining | Edit this page View Source AddRateLimiterWithAdapter(IServiceCollection, IConfiguration, RateLimiterStrategyType) Adds rate limiter services with adapter support for legacy code integration. Declaration public static IServiceCollection AddRateLimiterWithAdapter(this IServiceCollection services, IConfiguration configuration, RateLimiterStrategyType defaultStrategy = RateLimiterStrategyType.TokenBucket) Parameters Type Name Description IServiceCollection services The service collection IConfiguration configuration The configuration section containing rate limiter options RateLimiterStrategyType defaultStrategy The default strategy type to use Returns Type Description IServiceCollection The service collection for chaining"
  },
  "api/RateLimiter.Extensions.html": {
    "href": "api/RateLimiter.Extensions.html",
    "title": "Namespace RateLimiter.Extensions | RateLimiter Library Documentation",
    "summary": "Namespace RateLimiter.Extensions Classes ServiceCollectionExtensions Extension methods for setting up rate limiter services in DI container."
  },
  "api/RateLimiter.Implementations.FixedWindowStrategy.html": {
    "href": "api/RateLimiter.Implementations.FixedWindowStrategy.html",
    "title": "Class FixedWindowStrategy | RateLimiter Library Documentation",
    "summary": "Class FixedWindowStrategy Fixed window rate limiter strategy implementation. The fixed window algorithm maintains a counter for a fixed time window. The counter resets at the start of each window period. Inheritance object FixedWindowStrategy Implements IRateLimiter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Implementations Assembly: RateLimiter.dll Syntax public class FixedWindowStrategy : IRateLimiter Constructors | Edit this page View Source FixedWindowStrategy(IOptions<RateLimiterOptions>) Declaration public FixedWindowStrategy(IOptions<RateLimiterOptions> options) Parameters Type Name Description IOptions<RateLimiterOptions> options Properties | Edit this page View Source CurrentWindow Gets the current request count and window information (for testing/debugging purposes) Declaration public (int RequestCount, DateTime WindowStart, DateTime WindowEnd) CurrentWindow { get; } Property Value Type Description (int RequestCount, DateTime WindowStart, DateTime WindowEnd) Methods | Edit this page View Source GetAvailablePermitsAsync(CancellationToken) Gets the current number of available permits Declaration public Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task<int> Number of available permits | Edit this page View Source GetWaitTimeAsync(int, CancellationToken) Gets the time to wait before the next permit becomes available Declaration public Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits needed CancellationToken cancellationToken Cancellation token Returns Type Description Task<TimeSpan> Time to wait, or TimeSpan.Zero if permits are available now | Edit this page View Source ResetAsync(CancellationToken) Resets the rate limiter state Declaration public Task ResetAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task | Edit this page View Source TryConsumeAsync(int, CancellationToken) Attempts to consume the specified number of permits Declaration public Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits to consume (default: 1) CancellationToken cancellationToken Cancellation token Returns Type Description Task<bool> True if permits were consumed, false if rate limit exceeded Implements IRateLimiter"
  },
  "api/RateLimiter.Implementations.SlidingWindowStrategy.html": {
    "href": "api/RateLimiter.Implementations.SlidingWindowStrategy.html",
    "title": "Class SlidingWindowStrategy | RateLimiter Library Documentation",
    "summary": "Class SlidingWindowStrategy Sliding window rate limiter strategy implementation. The sliding window algorithm divides the time window into smaller sub-windows and tracks requests across these sub-windows for more accurate rate limiting. Inheritance object SlidingWindowStrategy Implements IRateLimiter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Implementations Assembly: RateLimiter.dll Syntax public class SlidingWindowStrategy : IRateLimiter Constructors | Edit this page View Source SlidingWindowStrategy(IOptions<RateLimiterOptions>) Declaration public SlidingWindowStrategy(IOptions<RateLimiterOptions> options) Parameters Type Name Description IOptions<RateLimiterOptions> options Properties | Edit this page View Source CurrentSubWindowCounts Gets the current sub-window counts (for testing/debugging purposes) Declaration public int[] CurrentSubWindowCounts { get; } Property Value Type Description int[] Methods | Edit this page View Source GetAvailablePermitsAsync(CancellationToken) Gets the current number of available permits Declaration public Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task<int> Number of available permits | Edit this page View Source GetWaitTimeAsync(int, CancellationToken) Gets the time to wait before the next permit becomes available Declaration public Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits needed CancellationToken cancellationToken Cancellation token Returns Type Description Task<TimeSpan> Time to wait, or TimeSpan.Zero if permits are available now | Edit this page View Source ResetAsync(CancellationToken) Resets the rate limiter state Declaration public Task ResetAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task | Edit this page View Source TryConsumeAsync(int, CancellationToken) Attempts to consume the specified number of permits Declaration public Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits to consume (default: 1) CancellationToken cancellationToken Cancellation token Returns Type Description Task<bool> True if permits were consumed, false if rate limit exceeded Implements IRateLimiter"
  },
  "api/RateLimiter.Implementations.TokenBucket.html": {
    "href": "api/RateLimiter.Implementations.TokenBucket.html",
    "title": "Class TokenBucket | RateLimiter Library Documentation",
    "summary": "Class TokenBucket Token bucket rate limiter - backward compatibility wrapper. For new code, use TokenBucketStrategy directly or RateLimiterFactory. Inheritance object TokenBucket Implements IRateLimiter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Implementations Assembly: RateLimiter.dll Syntax public class TokenBucket : IRateLimiter Constructors | Edit this page View Source TokenBucket(IOptions<RateLimiterOptions>) Declaration public TokenBucket(IOptions<RateLimiterOptions> options) Parameters Type Name Description IOptions<RateLimiterOptions> options Properties | Edit this page View Source CurrentTokens Gets the current token count (for testing/debugging purposes) Declaration public double CurrentTokens { get; } Property Value Type Description double Methods | Edit this page View Source GetAvailablePermitsAsync(CancellationToken) Gets the current number of available permits Declaration public Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task<int> Number of available permits | Edit this page View Source GetWaitTimeAsync(int, CancellationToken) Gets the time to wait before the next permit becomes available Declaration public Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits needed CancellationToken cancellationToken Cancellation token Returns Type Description Task<TimeSpan> Time to wait, or TimeSpan.Zero if permits are available now | Edit this page View Source ResetAsync(CancellationToken) Resets the rate limiter state Declaration public Task ResetAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task | Edit this page View Source TryConsumeAsync(int, CancellationToken) Attempts to consume the specified number of permits Declaration public Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits to consume (default: 1) CancellationToken cancellationToken Cancellation token Returns Type Description Task<bool> True if permits were consumed, false if rate limit exceeded Implements IRateLimiter"
  },
  "api/RateLimiter.Implementations.TokenBucketStrategy.html": {
    "href": "api/RateLimiter.Implementations.TokenBucketStrategy.html",
    "title": "Class TokenBucketStrategy | RateLimiter Library Documentation",
    "summary": "Class TokenBucketStrategy Token bucket rate limiter strategy implementation. The token bucket algorithm allows for bursty traffic while maintaining an average rate limit. Tokens are added to a bucket at a fixed rate. Inheritance object TokenBucketStrategy Implements IRateLimiter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Implementations Assembly: RateLimiter.dll Syntax public class TokenBucketStrategy : IRateLimiter Constructors | Edit this page View Source TokenBucketStrategy(IOptions<RateLimiterOptions>) Declaration public TokenBucketStrategy(IOptions<RateLimiterOptions> options) Parameters Type Name Description IOptions<RateLimiterOptions> options Properties | Edit this page View Source CurrentTokens Gets the current token count (for testing/debugging purposes) Declaration public double CurrentTokens { get; } Property Value Type Description double Methods | Edit this page View Source GetAvailablePermitsAsync(CancellationToken) Gets the current number of available permits Declaration public Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task<int> Number of available permits | Edit this page View Source GetWaitTimeAsync(int, CancellationToken) Gets the time to wait before the next permit becomes available Declaration public Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits needed CancellationToken cancellationToken Cancellation token Returns Type Description Task<TimeSpan> Time to wait, or TimeSpan.Zero if permits are available now | Edit this page View Source ResetAsync(CancellationToken) Resets the rate limiter state Declaration public Task ResetAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task | Edit this page View Source TryConsumeAsync(int, CancellationToken) Attempts to consume the specified number of permits Declaration public Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits to consume (default: 1) CancellationToken cancellationToken Cancellation token Returns Type Description Task<bool> True if permits were consumed, false if rate limit exceeded Implements IRateLimiter"
  },
  "api/RateLimiter.Implementations.html": {
    "href": "api/RateLimiter.Implementations.html",
    "title": "Namespace RateLimiter.Implementations | RateLimiter Library Documentation",
    "summary": "Namespace RateLimiter.Implementations Classes FixedWindowStrategy Fixed window rate limiter strategy implementation. The fixed window algorithm maintains a counter for a fixed time window. The counter resets at the start of each window period. SlidingWindowStrategy Sliding window rate limiter strategy implementation. The sliding window algorithm divides the time window into smaller sub-windows and tracks requests across these sub-windows for more accurate rate limiting. TokenBucket Token bucket rate limiter - backward compatibility wrapper. For new code, use TokenBucketStrategy directly or RateLimiterFactory. TokenBucketStrategy Token bucket rate limiter strategy implementation. The token bucket algorithm allows for bursty traffic while maintaining an average rate limit. Tokens are added to a bucket at a fixed rate."
  },
  "api/RateLimiter.Interfaces.IRateLimiter.html": {
    "href": "api/RateLimiter.Interfaces.IRateLimiter.html",
    "title": "Interface IRateLimiter | RateLimiter Library Documentation",
    "summary": "Interface IRateLimiter Interface for rate limiting implementations Namespace: RateLimiter.Interfaces Assembly: RateLimiter.dll Syntax public interface IRateLimiter Methods | Edit this page View Source GetAvailablePermitsAsync(CancellationToken) Gets the current number of available permits Declaration Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task<int> Number of available permits | Edit this page View Source GetWaitTimeAsync(int, CancellationToken) Gets the time to wait before the next permit becomes available Declaration Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits needed CancellationToken cancellationToken Cancellation token Returns Type Description Task<TimeSpan> Time to wait, or TimeSpan.Zero if permits are available now | Edit this page View Source ResetAsync(CancellationToken) Resets the rate limiter state Declaration Task ResetAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task | Edit this page View Source TryConsumeAsync(int, CancellationToken) Attempts to consume the specified number of permits Declaration Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits to consume (default: 1) CancellationToken cancellationToken Cancellation token Returns Type Description Task<bool> True if permits were consumed, false if rate limit exceeded"
  },
  "api/RateLimiter.Interfaces.html": {
    "href": "api/RateLimiter.Interfaces.html",
    "title": "Namespace RateLimiter.Interfaces | RateLimiter Library Documentation",
    "summary": "Namespace RateLimiter.Interfaces Interfaces IRateLimiter Interface for rate limiting implementations"
  },
  "api/RateLimiter.Services.RateLimiterContext.html": {
    "href": "api/RateLimiter.Services.RateLimiterContext.html",
    "title": "Class RateLimiterContext | RateLimiter Library Documentation",
    "summary": "Class RateLimiterContext Rate limiter context that uses the strategy pattern to switch between different rate limiting algorithms. This allows for runtime strategy selection and testing different algorithms. Inheritance object RateLimiterContext Implements IRateLimiter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Services Assembly: RateLimiter.dll Syntax public class RateLimiterContext : IRateLimiter Constructors | Edit this page View Source RateLimiterContext(IRateLimiter) Initializes the context with a default strategy. Declaration public RateLimiterContext(IRateLimiter strategy) Parameters Type Name Description IRateLimiter strategy The initial rate limiting strategy to use Properties | Edit this page View Source CurrentStrategyName Gets the current strategy type name for debugging/logging purposes. Declaration public string CurrentStrategyName { get; } Property Value Type Description string Methods | Edit this page View Source GetAvailablePermitsAsync(CancellationToken) Gets the current number of available permits Declaration public Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task<int> Number of available permits | Edit this page View Source GetWaitTimeAsync(int, CancellationToken) Gets the time to wait before the next permit becomes available Declaration public Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits needed CancellationToken cancellationToken Cancellation token Returns Type Description Task<TimeSpan> Time to wait, or TimeSpan.Zero if permits are available now | Edit this page View Source ResetAsync(CancellationToken) Resets the rate limiter state Declaration public Task ResetAsync(CancellationToken cancellationToken = default) Parameters Type Name Description CancellationToken cancellationToken Cancellation token Returns Type Description Task | Edit this page View Source SetStrategy(IRateLimiter) Changes the rate limiting strategy at runtime. Declaration public void SetStrategy(IRateLimiter strategy) Parameters Type Name Description IRateLimiter strategy The new strategy to use | Edit this page View Source TryConsumeAsync(int, CancellationToken) Attempts to consume the specified number of permits Declaration public Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) Parameters Type Name Description int permits Number of permits to consume (default: 1) CancellationToken cancellationToken Cancellation token Returns Type Description Task<bool> True if permits were consumed, false if rate limit exceeded Implements IRateLimiter"
  },
  "api/RateLimiter.Services.RateLimiterFactory.html": {
    "href": "api/RateLimiter.Services.RateLimiterFactory.html",
    "title": "Class RateLimiterFactory | RateLimiter Library Documentation",
    "summary": "Class RateLimiterFactory Factory for creating different rate limiting strategies. Inheritance object RateLimiterFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: RateLimiter.Services Assembly: RateLimiter.dll Syntax public class RateLimiterFactory Constructors | Edit this page View Source RateLimiterFactory(IOptions<RateLimiterOptions>) Declaration public RateLimiterFactory(IOptions<RateLimiterOptions> options) Parameters Type Name Description IOptions<RateLimiterOptions> options Methods | Edit this page View Source CreateFixedWindow() Creates a fixed window rate limiter strategy. Declaration public IRateLimiter CreateFixedWindow() Returns Type Description IRateLimiter | Edit this page View Source CreateSlidingWindow() Creates a sliding window rate limiter strategy. Declaration public IRateLimiter CreateSlidingWindow() Returns Type Description IRateLimiter | Edit this page View Source CreateStrategy(RateLimiterStrategyType) Creates a rate limiter strategy based on the specified type. Declaration public IRateLimiter CreateStrategy(RateLimiterStrategyType strategyType) Parameters Type Name Description RateLimiterStrategyType strategyType The type of strategy to create Returns Type Description IRateLimiter | Edit this page View Source CreateTokenBucket() Creates a token bucket rate limiter strategy. Declaration public IRateLimiter CreateTokenBucket() Returns Type Description IRateLimiter"
  },
  "api/RateLimiter.Services.RateLimiterStrategyType.html": {
    "href": "api/RateLimiter.Services.RateLimiterStrategyType.html",
    "title": "Enum RateLimiterStrategyType | RateLimiter Library Documentation",
    "summary": "Enum RateLimiterStrategyType Enumeration of available rate limiting strategy types. Namespace: RateLimiter.Services Assembly: RateLimiter.dll Syntax public enum RateLimiterStrategyType Fields Name Description FixedWindow SlidingWindow TokenBucket"
  },
  "api/RateLimiter.Services.html": {
    "href": "api/RateLimiter.Services.html",
    "title": "Namespace RateLimiter.Services | RateLimiter Library Documentation",
    "summary": "Namespace RateLimiter.Services Classes RateLimiterContext Rate limiter context that uses the strategy pattern to switch between different rate limiting algorithms. This allows for runtime strategy selection and testing different algorithms. RateLimiterFactory Factory for creating different rate limiting strategies. Enums RateLimiterStrategyType Enumeration of available rate limiting strategy types."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | RateLimiter Library Documentation",
    "summary": "API Reference Welcome to the RateLimiter API reference documentation. This section provides detailed information about all public classes, interfaces, and methods in the RateLimiter library. Core Interfaces IRateLimiter The main interface that all rate limiting strategies implement. Provides methods for consuming permits, checking availability, and managing rate limiter state. Key Methods: TryConsumeAsync(int permits, CancellationToken cancellationToken) - Attempts to consume permits GetAvailablePermitsAsync(CancellationToken cancellationToken) - Gets current available permits GetWaitTimeAsync(int permits, CancellationToken cancellationToken) - Calculates wait time for permits ResetAsync(CancellationToken cancellationToken) - Resets the rate limiter state Strategy Implementations TokenBucketStrategy Implements the token bucket algorithm, allowing burst traffic up to a configured capacity while maintaining a steady refill rate. Best For: APIs that need to handle burst traffic while maintaining overall rate limits. FixedWindowStrategy Implements fixed window counting, resetting the counter at fixed intervals. Best For: Simple rate limiting scenarios where memory efficiency is important. SlidingWindowStrategy Implements sliding window counting, maintaining a rolling window of request timestamps for precise rate limiting. Best For: Scenarios requiring strict, smooth rate limiting without burst allowances. Legacy Support TokenBucket Legacy wrapper around TokenBucketStrategy for backward compatibility. Adapter Pattern IRateLimiterAdapter Extended interface providing additional functionality like strategy introspection and debugging. TokenBucketAdapter Adapter implementation specifically for token bucket strategy with additional features. UniversalRateLimiterAdapter Universal adapter that can wrap any IRateLimiter implementation. Configuration RateLimiterOptions Main configuration class for rate limiters, supporting all algorithms and their specific options. Key Properties: Algorithm - The rate limiting algorithm to use Capacity - Maximum permits or requests allowed RefillRate - Rate at which tokens are refilled (TokenBucket only) RefillPeriod - Period for token refill (TokenBucket only) WindowSize - Size of the time window (Window-based algorithms) DistributedCacheKey - Key for distributed scenarios Algorithm-Specific Options TokenBucketOptions - Token bucket specific configuration FixedWindowOptions - Fixed window specific configuration SlidingWindowOptions - Sliding window specific configuration Services and Factories RateLimiterFactory Factory class for creating rate limiter instances based on configuration. RateLimiterContext Context class providing strategy pattern implementation for runtime algorithm switching. ServiceCollectionExtensions Extension methods for registering rate limiter services with dependency injection containers. Namespaces RateLimiter.Interfaces - Core interfaces RateLimiter.Implementations - Rate limiting algorithm implementations RateLimiter.Adapters - Adapter pattern implementations RateLimiter.Configuration - Configuration classes and options RateLimiter.Services - Service classes and factories RateLimiter.Extensions - Dependency injection extensions Quick Start // Configure in dependency injection services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 100; options.RefillRate = 10; options.RefillPeriod = TimeSpan.FromSeconds(1); }); services.AddRateLimiter(); // Use in your service public class MyService { private readonly IRateLimiter _rateLimiter; public MyService(IRateLimiter rateLimiter) { _rateLimiter = rateLimiter; } public async Task<bool> ProcessRequestAsync() { return await _rateLimiter.TryConsumeAsync(); } } Thread Safety All rate limiter implementations are thread-safe and designed for high-concurrency scenarios. The library uses appropriate locking mechanisms and concurrent data structures to ensure correctness under load. Performance Characteristics Algorithm Memory Usage CPU Usage Accuracy Burst Handling Token Bucket Low Very Low High Excellent Fixed Window Very Low Very Low Good Poor Sliding Window High Higher Excellent Good For detailed performance guidance, see the Performance Considerations guide."
  },
  "articles/architecture.html": {
    "href": "articles/architecture.html",
    "title": "Architecture Guide | RateLimiter Library Documentation",
    "summary": "Architecture Guide This guide explains the architectural patterns and design principles used in the RateLimiter library. Design Patterns Strategy Pattern The Strategy pattern allows the rate limiting algorithm to be selected at runtime: // IRateLimiter is the strategy interface public interface IRateLimiter { Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default); Task<int> GetAvailablePermitsAsync(CancellationToken cancellationToken = default); Task<TimeSpan> GetWaitTimeAsync(int permits = 1, CancellationToken cancellationToken = default); Task ResetAsync(CancellationToken cancellationToken = default); } // Concrete strategies public class TokenBucketStrategy : IRateLimiter { /* ... */ } public class FixedWindowStrategy : IRateLimiter { /* ... */ } public class SlidingWindowStrategy : IRateLimiter { /* ... */ } Benefits: Easy to switch algorithms at runtime Each algorithm is independently testable New algorithms can be added without modifying existing code Adapter Pattern The Adapter pattern provides backward compatibility and legacy interface support: public interface IRateLimiterAdapter : IRateLimiter { string StrategyTypeName { get; } void SetStrategy(IRateLimiter strategy); string GetDebugInfo(); } public class TokenBucketAdapter : IRateLimiterAdapter { private readonly TokenBucketStrategy _strategy; public TokenBucketAdapter(IOptions<RateLimiterOptions> options) { _strategy = new TokenBucketStrategy(options); } // Adapter methods delegate to the strategy public Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) => _strategy.TryConsumeAsync(permits, cancellationToken); } Benefits: Maintains compatibility with legacy code Provides additional features (debug info, strategy introspection) Allows gradual migration to new interfaces Factory Pattern The Factory pattern creates appropriate rate limiter instances based on configuration: public class RateLimiterFactory { private readonly IOptions<RateLimiterOptions> _options; public RateLimiterFactory(IOptions<RateLimiterOptions> options) { _options = options; } public IRateLimiter CreateRateLimiter() { return _options.Value.Algorithm switch { RateLimitingAlgorithm.TokenBucket => new TokenBucketStrategy(_options), RateLimitingAlgorithm.FixedWindow => new FixedWindowStrategy(_options), RateLimitingAlgorithm.SlidingWindow => new SlidingWindowStrategy(_options), _ => throw new ArgumentException($\"Unknown algorithm: {_options.Value.Algorithm}\") }; } } Benefits: Centralizes object creation logic Supports configuration-driven instantiation Easy to extend with new algorithms Options Pattern The Options pattern provides type-safe configuration management: public class RateLimiterOptions { public const string SectionName = \"RateLimiter\"; public RateLimitingAlgorithm Algorithm { get; set; } = RateLimitingAlgorithm.TokenBucket; public int Capacity { get; set; } = 100; public double RefillRate { get; set; } = 10; public TimeSpan RefillPeriod { get; set; } = TimeSpan.FromSeconds(1); public TimeSpan WindowSize { get; set; } = TimeSpan.FromMinutes(1); public string? DistributedCacheKey { get; set; } } Benefits: Type-safe configuration Supports validation Integrates with ASP.NET Core configuration system Architectural Layers 1. Interface Layer ┌─────────────────────────────────────┐ │ IRateLimiter │ │ (Core Interface) │ └─────────────────────────────────────┘ 2. Strategy Layer ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ TokenBucket │ │ FixedWindow │ │ SlidingWindow │ │ Strategy │ │ Strategy │ │ Strategy │ └─────────────────┘ └─────────────────┘ └─────────────────┘ 3. Adapter Layer ┌─────────────────┐ ┌─────────────────┐ │ TokenBucket │ │ Universal │ │ Adapter │ │ Adapter │ └─────────────────┘ └─────────────────┘ 4. Service Layer ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ RateLimiter │ │ RateLimiter │ │ Service │ │ Factory │ │ Context │ │ Extensions │ └─────────────────┘ └─────────────────┘ └─────────────────┘ Thread Safety All rate limiter implementations are designed to be thread-safe: Lock-Free Optimizations public class TokenBucketStrategy : IRateLimiter { private readonly object _lock = new object(); private double _tokens; private DateTime _lastRefill; public async Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) { lock (_lock) { Refill(); if (_tokens >= permits) { _tokens -= permits; return true; } return false; } } } Concurrent Collections // For sliding window, using concurrent data structures private readonly ConcurrentQueue<DateTime> _requestTimes = new(); Extension Points Custom Algorithms To add a new rate limiting algorithm: Implement IRateLimiter: public class CustomRateLimiter : IRateLimiter { public async Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) { // Your custom logic here throw new NotImplementedException(); } // Implement other methods... } Add to the factory: public enum RateLimitingAlgorithm { TokenBucket, FixedWindow, SlidingWindow, Custom // Add your algorithm } // Update factory public IRateLimiter CreateRateLimiter() { return _options.Value.Algorithm switch { // ... existing cases RateLimitingAlgorithm.Custom => new CustomRateLimiter(_options), _ => throw new ArgumentException($\"Unknown algorithm: {_options.Value.Algorithm}\") }; } Custom Storage Backends For distributed scenarios, you can implement custom storage: public interface IRateLimiterStorage { Task<T> GetAsync<T>(string key); Task SetAsync<T>(string key, T value, TimeSpan? expiry = null); Task<bool> TryLockAsync(string key, TimeSpan timeout); Task ReleaseLockAsync(string key); } public class RedisRateLimiterStorage : IRateLimiterStorage { // Implementation using Redis } Error Handling Strategy Graceful Degradation public class ResilientRateLimiter : IRateLimiter { private readonly IRateLimiter _primary; private readonly IRateLimiter _fallback; public async Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) { try { return await _primary.TryConsumeAsync(permits, cancellationToken); } catch (Exception ex) { // Log error and use fallback return await _fallback.TryConsumeAsync(permits, cancellationToken); } } } Circuit Breaker Pattern public class CircuitBreakerRateLimiter : IRateLimiter { private readonly IRateLimiter _inner; private readonly CircuitBreaker _circuitBreaker; public async Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) { if (_circuitBreaker.State == CircuitBreakerState.Open) { // Fail fast return false; } try { var result = await _inner.TryConsumeAsync(permits, cancellationToken); _circuitBreaker.RecordSuccess(); return result; } catch (Exception ex) { _circuitBreaker.RecordFailure(); throw; } } } Testing Architecture Unit Testing [TestFixture] public class TokenBucketStrategyTests { private TokenBucketStrategy _rateLimiter; private RateLimiterOptions _options; [SetUp] public void Setup() { _options = new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.TokenBucket, Capacity = 10, RefillRate = 1, RefillPeriod = TimeSpan.FromSeconds(1) }; _rateLimiter = new TokenBucketStrategy(Options.Create(_options)); } [Test] public async Task ShouldAllowRequestsUnderCapacity() { // Test implementation } } Integration Testing [TestFixture] public class RateLimiterIntegrationTests { private WebApplicationFactory<Program> _factory; private HttpClient _client; [SetUp] public void Setup() { _factory = new WebApplicationFactory<Program>() .WithWebHostBuilder(builder => { builder.ConfigureServices(services => { services.Configure<RateLimiterOptions>(options => { options.Capacity = 5; options.RefillRate = 1; options.RefillPeriod = TimeSpan.FromSeconds(1); }); }); }); _client = _factory.CreateClient(); } } Deployment Considerations Distributed Deployments Use Redis for shared state Configure appropriate timeout values Consider network partitions and failover scenarios Performance Monitoring Track rate limiter hit rates Monitor response times Alert on error rates Configuration Management Use environment-specific configurations Support hot configuration reloading Validate configuration at startup"
  },
  "articles/configuration.html": {
    "href": "articles/configuration.html",
    "title": "Configuration Guide | RateLimiter Library Documentation",
    "summary": "Configuration Guide This guide covers all configuration options available in the RateLimiter library. Configuration Options RateLimiterOptions The main configuration class that defines how your rate limiter behaves: public class RateLimiterOptions { public RateLimitingAlgorithm Algorithm { get; set; } public int Capacity { get; set; } public double RefillRate { get; set; } public TimeSpan RefillPeriod { get; set; } public TimeSpan WindowSize { get; set; } public string? DistributedCacheKey { get; set; } } Algorithm Types TokenBucket services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 100; // Maximum tokens options.RefillRate = 10; // Tokens per period options.RefillPeriod = TimeSpan.FromSeconds(1); }); FixedWindow services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.FixedWindow; options.Capacity = 100; // Requests per window options.WindowSize = TimeSpan.FromMinutes(1); }); SlidingWindow services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.SlidingWindow; options.Capacity = 100; // Requests per window options.WindowSize = TimeSpan.FromMinutes(1); }); Configuration Sources appsettings.json { \"RateLimiter\": { \"Algorithm\": \"TokenBucket\", \"Capacity\": 100, \"RefillRate\": 10, \"RefillPeriod\": \"00:00:01\", \"WindowSize\": \"00:01:00\", \"DistributedCacheKey\": \"MyApp:RateLimit\" } } Environment Variables RateLimiter__Algorithm=TokenBucket RateLimiter__Capacity=100 RateLimiter__RefillRate=10 RateLimiter__RefillPeriod=00:00:01 Code-based Configuration services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 100; options.RefillRate = 10; options.RefillPeriod = TimeSpan.FromSeconds(1); }); Advanced Configuration Multiple Rate Limiters // Configure different rate limiters for different scenarios services.Configure<RateLimiterOptions>(\"ApiRateLimit\", options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 1000; options.RefillRate = 100; options.RefillPeriod = TimeSpan.FromSeconds(1); }); services.Configure<RateLimiterOptions>(\"AuthRateLimit\", options => { options.Algorithm = RateLimitingAlgorithm.FixedWindow; options.Capacity = 5; options.WindowSize = TimeSpan.FromMinutes(1); }); Distributed Scenarios services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 100; options.RefillRate = 10; options.RefillPeriod = TimeSpan.FromSeconds(1); options.DistributedCacheKey = \"MyApp:GlobalRateLimit\"; }); // Add Redis distributed cache services.AddStackExchangeRedisCache(options => { options.Configuration = \"localhost:6379\"; }); Validation The library automatically validates configuration: Capacity must be greater than 0 RefillRate must be greater than 0 for TokenBucket RefillPeriod must be greater than TimeSpan.Zero for TokenBucket WindowSize must be greater than TimeSpan.Zero for window-based algorithms Invalid configurations will throw ArgumentException during service registration."
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started | RateLimiter Library Documentation",
    "summary": "Getting Started This guide will help you get up and running with the RateLimiter library quickly. Installation The RateLimiter library is available as a NuGet package. You can install it using the Package Manager Console in Visual Studio: Install-Package RateLimiter Or using the .NET CLI: dotnet add package RateLimiter Basic Setup 1. Configure Services First, configure the rate limiter in your dependency injection container: using Microsoft.Extensions.DependencyInjection; using RateLimiter.Configuration; using RateLimiter.Extensions; // In your Startup.cs or Program.cs services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 100; options.RefillRate = 10; options.RefillPeriod = TimeSpan.FromSeconds(1); }); // Register the rate limiter services services.AddRateLimiter(); 2. Use in Your Application Inject the rate limiter into your services: using RateLimiter.Interfaces; public class ApiController { private readonly IRateLimiter _rateLimiter; public ApiController(IRateLimiter rateLimiter) { _rateLimiter = rateLimiter; } public async Task<IActionResult> ProcessRequest() { // Check if we can process the request if (!await _rateLimiter.TryConsumeAsync()) { return StatusCode(429, \"Rate limit exceeded\"); } // Process the request return Ok(\"Request processed successfully\"); } } Configuration Options Basic Configuration services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 100; // Maximum tokens/requests options.RefillRate = 10; // Tokens added per period options.RefillPeriod = TimeSpan.FromSeconds(1); }); Configuration from appsettings.json { \"RateLimiter\": { \"Algorithm\": \"TokenBucket\", \"Capacity\": 100, \"RefillRate\": 10, \"RefillPeriod\": \"00:00:01\" } } Then in your startup code: services.Configure<RateLimiterOptions>( configuration.GetSection(\"RateLimiter\")); Algorithm Selection Choose the appropriate algorithm based on your needs: Token Bucket (Recommended) Allows burst traffic up to capacity Smooth rate limiting over time Good for APIs with occasional spikes options.Algorithm = RateLimitingAlgorithm.TokenBucket; Fixed Window Simple and memory efficient Counts requests in fixed time windows May allow bursts at window boundaries options.Algorithm = RateLimitingAlgorithm.FixedWindow; Sliding Window Most accurate rate limiting Higher memory usage Best for strict rate limiting requirements options.Algorithm = RateLimitingAlgorithm.SlidingWindow; Next Steps Configuration Guide - Learn about all available configuration options Usage Examples - See practical examples for different scenarios Performance Considerations - Optimize for your specific use case API Reference - Detailed API documentation"
  },
  "articles/performance.html": {
    "href": "articles/performance.html",
    "title": "Performance Considerations | RateLimiter Library Documentation",
    "summary": "Performance Considerations This guide covers performance optimization strategies when using the RateLimiter library. Algorithm Performance Comparison Token Bucket Memory Usage: Low (constant memory per instance) CPU Usage: Very low (simple arithmetic operations) Accuracy: High Burst Handling: Excellent (designed for bursts) Best For: APIs that can handle burst traffic Fixed Window Memory Usage: Very low (just a counter and timestamp) CPU Usage: Very low (minimal operations) Accuracy: Good (window boundary issues) Burst Handling: Poor (can allow 2x capacity at boundaries) Best For: Simple rate limiting with minimal overhead Sliding Window Memory Usage: High (stores individual request timestamps) CPU Usage: Higher (must clean up expired entries) Accuracy: Excellent (most precise) Burst Handling: Good (smooth distribution) Best For: Strict rate limiting requirements Optimization Strategies 1. Choose the Right Algorithm // For high-throughput scenarios with burst tolerance services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 1000; options.RefillRate = 100; options.RefillPeriod = TimeSpan.FromSeconds(1); }); // For minimal memory usage services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.FixedWindow; options.Capacity = 100; options.WindowSize = TimeSpan.FromMinutes(1); }); // For strict accuracy requirements services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.SlidingWindow; options.Capacity = 100; options.WindowSize = TimeSpan.FromMinutes(1); }); 2. Minimize Lock Contention The library uses optimized locking strategies, but you can help by: // Use separate rate limiters for different operations public class OptimizedService { private readonly IRateLimiter _readLimiter; private readonly IRateLimiter _writeLimiter; public OptimizedService(IRateLimiterFactory factory) { _readLimiter = factory.CreateRateLimiter(\"ReadOperations\"); _writeLimiter = factory.CreateRateLimiter(\"WriteOperations\"); } // This avoids contention between read and write operations } 3. Batch Operations When Possible public async Task<bool> ProcessBatchAsync(int itemCount) { // Try to consume permits for the entire batch at once if (await _rateLimiter.TryConsumeAsync(itemCount)) { // Process all items return true; } // Fallback: check available permits and process what we can var available = await _rateLimiter.GetAvailablePermitsAsync(); if (available > 0) { await _rateLimiter.TryConsumeAsync(available); // Process 'available' number of items return false; // Partial processing } return false; // No processing possible } 4. Avoid Frequent Polling // DON'T do this - wasteful polling public async Task BadPatternAsync() { while (!await _rateLimiter.TryConsumeAsync()) { await Task.Delay(10); // Wasteful } // Process request } // DO this instead - wait for the calculated time public async Task GoodPatternAsync() { var waitTime = await _rateLimiter.GetWaitTimeAsync(); if (waitTime > TimeSpan.Zero) { await Task.Delay(waitTime); } await _rateLimiter.TryConsumeAsync(); // Process request } Memory Management Sliding Window Cleanup The sliding window implementation automatically cleans up expired entries: // The library handles this automatically, but you can help by: // 1. Using appropriate window sizes (don't make them too large) services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.SlidingWindow; options.Capacity = 100; options.WindowSize = TimeSpan.FromMinutes(5); // Reasonable size }); // 2. Calling ResetAsync() when appropriate (e.g., user logout) public async Task OnUserLogoutAsync(string userId) { var userLimiter = _userLimiters.GetValueOrDefault(userId); if (userLimiter != null) { await userLimiter.ResetAsync(); _userLimiters.TryRemove(userId, out _); } } Per-User Rate Limiters public class EfficientUserRateLimitingService { private readonly ConcurrentDictionary<string, IRateLimiter> _userLimiters; private readonly Timer _cleanupTimer; public EfficientUserRateLimitingService() { _userLimiters = new ConcurrentDictionary<string, IRateLimiter>(); // Cleanup inactive limiters every 10 minutes _cleanupTimer = new Timer(CleanupInactiveLimiters, null, TimeSpan.FromMinutes(10), TimeSpan.FromMinutes(10)); } private void CleanupInactiveLimiters(object state) { var cutoff = DateTime.UtcNow.AddMinutes(-30); var inactiveUsers = new List<string>(); foreach (var kvp in _userLimiters) { // Check if limiter has been inactive if (IsInactive(kvp.Value, cutoff)) { inactiveUsers.Add(kvp.Key); } } foreach (var userId in inactiveUsers) { _userLimiters.TryRemove(userId, out _); } } } Distributed Performance Redis Optimization services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 1000; options.RefillRate = 100; options.RefillPeriod = TimeSpan.FromSeconds(1); // Use a descriptive key options.DistributedCacheKey = \"MyApp:API:RateLimit\"; }); // Configure Redis for better performance services.AddStackExchangeRedisCache(options => { options.Configuration = \"localhost:6379\"; options.InstanceName = \"MyApp\"; // Optimize for rate limiting workloads options.ConfigurationOptions = new StackExchange.Redis.ConfigurationOptions { EndPoints = { \"localhost:6379\" }, AbortOnConnectFail = false, ConnectRetry = 3, ConnectTimeout = 5000, ResponseTimeout = 5000, // Use connection pooling KeepAlive = 60 }; }); Monitoring and Metrics public class MonitoredRateLimiter : IRateLimiter { private readonly IRateLimiter _inner; private readonly IMetrics _metrics; public MonitoredRateLimiter(IRateLimiter inner, IMetrics metrics) { _inner = inner; _metrics = metrics; } public async Task<bool> TryConsumeAsync(int permits = 1, CancellationToken cancellationToken = default) { var stopwatch = Stopwatch.StartNew(); var result = await _inner.TryConsumeAsync(permits, cancellationToken); stopwatch.Stop(); _metrics.Record(\"rate_limiter.try_consume.duration\", stopwatch.ElapsedMilliseconds); _metrics.Counter(\"rate_limiter.requests.total\").Increment(); if (result) { _metrics.Counter(\"rate_limiter.requests.allowed\").Increment(); } else { _metrics.Counter(\"rate_limiter.requests.denied\").Increment(); } return result; } // Implement other methods similarly... } Performance Testing [Test] public async Task PerformanceTest() { var options = Options.Create(new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.TokenBucket, Capacity = 10000, RefillRate = 1000, RefillPeriod = TimeSpan.FromSeconds(1) }); var rateLimiter = new TokenBucketStrategy(options); var tasks = new List<Task<bool>>(); var stopwatch = Stopwatch.StartNew(); // Simulate 1000 concurrent requests for (int i = 0; i < 1000; i++) { tasks.Add(rateLimiter.TryConsumeAsync()); } var results = await Task.WhenAll(tasks); stopwatch.Stop(); Console.WriteLine($\"Processed 1000 requests in {stopwatch.ElapsedMilliseconds}ms\"); Console.WriteLine($\"Allowed: {results.Count(r => r)}\"); Console.WriteLine($\"Denied: {results.Count(r => !r)}\"); } Best Practices Summary Choose the right algorithm for your use case Use separate limiters for different operations to reduce contention Implement proper cleanup for per-user limiters Monitor performance with metrics Test under load to validate performance characteristics Configure Redis appropriately for distributed scenarios Avoid polling - use calculated wait times instead"
  },
  "articles/testing.html": {
    "href": "articles/testing.html",
    "title": "Testing Guide | RateLimiter Library Documentation",
    "summary": "Testing Guide This guide covers comprehensive testing strategies for the RateLimiter library. Unit Testing Testing Rate Limiter Algorithms Token Bucket Testing [TestFixture] public class TokenBucketStrategyTests { private TokenBucketStrategy _rateLimiter; private RateLimiterOptions _options; [SetUp] public void Setup() { _options = new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.TokenBucket, Capacity = 10, RefillRate = 5, RefillPeriod = TimeSpan.FromSeconds(1) }; _rateLimiter = new TokenBucketStrategy(Options.Create(_options)); } [Test] public async Task ShouldAllowRequestsUpToCapacity() { // Should allow up to capacity for (int i = 0; i < 10; i++) { Assert.IsTrue(await _rateLimiter.TryConsumeAsync()); } // Should deny the next request Assert.IsFalse(await _rateLimiter.TryConsumeAsync()); } [Test] public async Task ShouldRefillTokensOverTime() { // Consume all tokens for (int i = 0; i < 10; i++) { await _rateLimiter.TryConsumeAsync(); } // Wait for refill await Task.Delay(TimeSpan.FromSeconds(1.1)); // Should have 5 new tokens (refill rate) for (int i = 0; i < 5; i++) { Assert.IsTrue(await _rateLimiter.TryConsumeAsync(), $\"Token {i + 1} should be available\"); } Assert.IsFalse(await _rateLimiter.TryConsumeAsync(), \"No more tokens should be available\"); } [Test] public async Task ShouldHandleBurstTraffic() { // Allow burst up to capacity var tasks = new List<Task<bool>>(); for (int i = 0; i < 15; i++) { tasks.Add(_rateLimiter.TryConsumeAsync()); } var results = await Task.WhenAll(tasks); var allowed = results.Count(r => r); var denied = results.Count(r => !r); Assert.AreEqual(10, allowed, \"Should allow exactly 10 requests\"); Assert.AreEqual(5, denied, \"Should deny exactly 5 requests\"); } [Test] public async Task GetAvailablePermitsAsync_ShouldReturnCorrectCount() { // Initially should have full capacity var available = await _rateLimiter.GetAvailablePermitsAsync(); Assert.AreEqual(10, available); // After consuming some tokens await _rateLimiter.TryConsumeAsync(3); available = await _rateLimiter.GetAvailablePermitsAsync(); Assert.AreEqual(7, available); } [Test] public async Task GetWaitTimeAsync_ShouldCalculateCorrectWaitTime() { // Consume all tokens for (int i = 0; i < 10; i++) { await _rateLimiter.TryConsumeAsync(); } var waitTime = await _rateLimiter.GetWaitTimeAsync(); // Should need to wait approximately 1 second for next token Assert.IsTrue(waitTime.TotalMilliseconds > 900 && waitTime.TotalMilliseconds < 1100, $\"Wait time should be ~1000ms, but was {waitTime.TotalMilliseconds}ms\"); } [Test] public async Task ResetAsync_ShouldRestoreFullCapacity() { // Consume some tokens for (int i = 0; i < 5; i++) { await _rateLimiter.TryConsumeAsync(); } // Reset should restore full capacity await _rateLimiter.ResetAsync(); var available = await _rateLimiter.GetAvailablePermitsAsync(); Assert.AreEqual(10, available); } } Fixed Window Testing [TestFixture] public class FixedWindowStrategyTests { private FixedWindowStrategy _rateLimiter; [SetUp] public void Setup() { var options = new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.FixedWindow, Capacity = 5, WindowSize = TimeSpan.FromSeconds(2) }; _rateLimiter = new FixedWindowStrategy(Options.Create(options)); } [Test] public async Task ShouldAllowRequestsInWindow() { for (int i = 0; i < 5; i++) { Assert.IsTrue(await _rateLimiter.TryConsumeAsync()); } Assert.IsFalse(await _rateLimiter.TryConsumeAsync()); } [Test] public async Task ShouldResetAtWindowBoundary() { // Consume all requests in current window for (int i = 0; i < 5; i++) { await _rateLimiter.TryConsumeAsync(); } // Wait for window to reset await Task.Delay(TimeSpan.FromSeconds(2.1)); // Should allow requests again Assert.IsTrue(await _rateLimiter.TryConsumeAsync()); } } Sliding Window Testing [TestFixture] public class SlidingWindowStrategyTests { private SlidingWindowStrategy _rateLimiter; [SetUp] public void Setup() { var options = new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.SlidingWindow, Capacity = 5, WindowSize = TimeSpan.FromSeconds(5) }; _rateLimiter = new SlidingWindowStrategy(Options.Create(options)); } [Test] public async Task ShouldMaintainSlidingWindow() { // Make requests at 1-second intervals for (int i = 0; i < 5; i++) { Assert.IsTrue(await _rateLimiter.TryConsumeAsync()); if (i < 4) await Task.Delay(TimeSpan.FromSeconds(1)); } // Immediate next request should be denied Assert.IsFalse(await _rateLimiter.TryConsumeAsync()); // Wait 2 seconds (total 6 seconds from first request) await Task.Delay(TimeSpan.FromSeconds(2)); // First request should have expired from window Assert.IsTrue(await _rateLimiter.TryConsumeAsync()); } } Concurrency Testing Thread Safety Tests [TestFixture] public class ConcurrencyTests { [Test] public async Task ShouldBehavCorrectlyUnderConcurrentLoad() { var options = Options.Create(new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.TokenBucket, Capacity = 100, RefillRate = 10, RefillPeriod = TimeSpan.FromSeconds(1) }); var rateLimiter = new TokenBucketStrategy(options); var tasks = new List<Task<bool>>(); // Simulate 1000 concurrent requests for (int i = 0; i < 1000; i++) { tasks.Add(rateLimiter.TryConsumeAsync()); } var results = await Task.WhenAll(tasks); var allowed = results.Count(r => r); var denied = results.Count(r => !r); // Should allow exactly 100 requests (capacity) Assert.AreEqual(100, allowed); Assert.AreEqual(900, denied); // Total state should be consistent var available = await rateLimiter.GetAvailablePermitsAsync(); Assert.AreEqual(0, available); } [Test] public async Task ShouldHandleRaceConditions() { var options = Options.Create(new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.TokenBucket, Capacity = 1, RefillRate = 1, RefillPeriod = TimeSpan.FromSeconds(1) }); var rateLimiter = new TokenBucketStrategy(options); var successCount = 0; // Run many concurrent operations var tasks = Enumerable.Range(0, 100).Select(async _ => { for (int i = 0; i < 10; i++) { if (await rateLimiter.TryConsumeAsync()) { Interlocked.Increment(ref successCount); } await Task.Delay(10); } }); await Task.WhenAll(tasks); // Success count should be reasonable (allowing for some refill) Assert.IsTrue(successCount > 0 && successCount < 20, $\"Expected reasonable success count, got {successCount}\"); } } Integration Testing ASP.NET Core Integration [TestFixture] public class RateLimiterIntegrationTests { private WebApplicationFactory<Program> _factory; private HttpClient _client; [SetUp] public void Setup() { _factory = new WebApplicationFactory<Program>() .WithWebHostBuilder(builder => { builder.ConfigureServices(services => { services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 5; options.RefillRate = 1; options.RefillPeriod = TimeSpan.FromSeconds(1); }); services.AddRateLimiter(); }); builder.Configure(app => { app.UseMiddleware<RateLimitingMiddleware>(); app.UseRouting(); app.UseEndpoints(endpoints => { endpoints.MapGet(\"/test\", () => \"OK\"); }); }); }); _client = _factory.CreateClient(); } [Test] public async Task ShouldApplyRateLimitingToEndpoints() { var responses = new List<HttpResponseMessage>(); // Make requests up to limit for (int i = 0; i < 7; i++) { responses.Add(await _client.GetAsync(\"/test\")); } var okResponses = responses.Count(r => r.StatusCode == HttpStatusCode.OK); var rateLimitedResponses = responses.Count(r => r.StatusCode == HttpStatusCode.TooManyRequests); Assert.AreEqual(5, okResponses, \"Should allow 5 requests\"); Assert.AreEqual(2, rateLimitedResponses, \"Should rate limit 2 requests\"); } [TearDown] public void TearDown() { _client?.Dispose(); _factory?.Dispose(); } } Redis Integration Testing [TestFixture] public class RedisIntegrationTests { private ServiceProvider _serviceProvider; private IRateLimiter _rateLimiter; [SetUp] public void Setup() { var services = new ServiceCollection(); services.AddStackExchangeRedisCache(options => { options.Configuration = \"localhost:6379\"; }); services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 10; options.RefillRate = 5; options.RefillPeriod = TimeSpan.FromSeconds(1); options.DistributedCacheKey = \"Test:RateLimit\"; }); services.AddRateLimiter(); _serviceProvider = services.BuildServiceProvider(); _rateLimiter = _serviceProvider.GetRequiredService<IRateLimiter>(); } [Test] public async Task ShouldPersistStateInRedis() { // Consume some permits for (int i = 0; i < 5; i++) { await _rateLimiter.TryConsumeAsync(); } // Create new rate limiter instance (simulating app restart) var newRateLimiter = _serviceProvider.GetRequiredService<IRateLimiter>(); // Should maintain state from Redis var available = await newRateLimiter.GetAvailablePermitsAsync(); Assert.AreEqual(5, available); } [TearDown] public void TearDown() { _serviceProvider?.Dispose(); } } Performance Testing Benchmark Testing [MemoryDiagnoser] [SimpleJob(RuntimeMoniker.Net80)] public class RateLimiterBenchmarks { private TokenBucketStrategy _tokenBucket; private FixedWindowStrategy _fixedWindow; private SlidingWindowStrategy _slidingWindow; [GlobalSetup] public void Setup() { var tokenBucketOptions = Options.Create(new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.TokenBucket, Capacity = 1000, RefillRate = 100, RefillPeriod = TimeSpan.FromSeconds(1) }); var fixedWindowOptions = Options.Create(new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.FixedWindow, Capacity = 1000, WindowSize = TimeSpan.FromSeconds(10) }); var slidingWindowOptions = Options.Create(new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.SlidingWindow, Capacity = 1000, WindowSize = TimeSpan.FromSeconds(10) }); _tokenBucket = new TokenBucketStrategy(tokenBucketOptions); _fixedWindow = new FixedWindowStrategy(fixedWindowOptions); _slidingWindow = new SlidingWindowStrategy(slidingWindowOptions); } [Benchmark] public async Task<bool> TokenBucket_TryConsume() { return await _tokenBucket.TryConsumeAsync(); } [Benchmark] public async Task<bool> FixedWindow_TryConsume() { return await _fixedWindow.TryConsumeAsync(); } [Benchmark] public async Task<bool> SlidingWindow_TryConsume() { return await _slidingWindow.TryConsumeAsync(); } } Load Testing [TestFixture] public class LoadTests { [Test] public async Task ShouldHandleHighThroughput() { var options = Options.Create(new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.TokenBucket, Capacity = 10000, RefillRate = 1000, RefillPeriod = TimeSpan.FromSeconds(1) }); var rateLimiter = new TokenBucketStrategy(options); var stopwatch = Stopwatch.StartNew(); var totalRequests = 100000; var allowedRequests = 0; var tasks = Enumerable.Range(0, totalRequests).Select(async _ => { if (await rateLimiter.TryConsumeAsync()) { Interlocked.Increment(ref allowedRequests); } }); await Task.WhenAll(tasks); stopwatch.Stop(); var throughput = totalRequests / stopwatch.Elapsed.TotalSeconds; Console.WriteLine($\"Processed {totalRequests:N0} requests in {stopwatch.ElapsedMilliseconds:N0}ms\"); Console.WriteLine($\"Throughput: {throughput:N0} requests/second\"); Console.WriteLine($\"Allowed: {allowedRequests:N0} ({(double)allowedRequests/totalRequests:P2})\"); Assert.IsTrue(throughput > 10000, $\"Throughput should be > 10,000 req/s, was {throughput:F0}\"); } } Test Helpers and Utilities Time Mocking public interface ITimeProvider { DateTime UtcNow { get; } } public class SystemTimeProvider : ITimeProvider { public DateTime UtcNow => DateTime.UtcNow; } public class MockTimeProvider : ITimeProvider { public DateTime UtcNow { get; set; } = DateTime.UtcNow; public void Advance(TimeSpan timeSpan) { UtcNow = UtcNow.Add(timeSpan); } } // In your tests [Test] public async Task ShouldRefillAfterTimePasses() { var mockTime = new MockTimeProvider(); var rateLimiter = new TokenBucketStrategy(options, mockTime); // Consume all tokens for (int i = 0; i < 10; i++) { await rateLimiter.TryConsumeAsync(); } // Advance time mockTime.Advance(TimeSpan.FromSeconds(1)); // Should have new tokens Assert.IsTrue(await rateLimiter.TryConsumeAsync()); } Test Data Builders public class RateLimiterOptionsBuilder { private readonly RateLimiterOptions _options = new(); public RateLimiterOptionsBuilder WithTokenBucket(int capacity, double refillRate, TimeSpan refillPeriod) { _options.Algorithm = RateLimitingAlgorithm.TokenBucket; _options.Capacity = capacity; _options.RefillRate = refillRate; _options.RefillPeriod = refillPeriod; return this; } public RateLimiterOptionsBuilder WithFixedWindow(int capacity, TimeSpan windowSize) { _options.Algorithm = RateLimitingAlgorithm.FixedWindow; _options.Capacity = capacity; _options.WindowSize = windowSize; return this; } public RateLimiterOptions Build() => _options; } // Usage in tests var options = new RateLimiterOptionsBuilder() .WithTokenBucket(capacity: 100, refillRate: 10, refillPeriod: TimeSpan.FromSeconds(1)) .Build(); Testing Best Practices Test All Algorithms: Ensure each rate limiting algorithm is thoroughly tested Test Concurrency: Verify thread safety under load Test Time Boundaries: Test behavior at window boundaries and during refill periods Test Error Conditions: Verify behavior when dependencies fail Performance Testing: Benchmark different algorithms and configurations Integration Testing: Test the full stack including middleware and DI Use Deterministic Time: Mock time providers for predictable tests"
  },
  "articles/usage-examples.html": {
    "href": "articles/usage-examples.html",
    "title": "Usage Examples | RateLimiter Library Documentation",
    "summary": "Usage Examples This page provides practical examples of how to use the RateLimiter library in different scenarios. Basic Usage Simple API Rate Limiting [ApiController] [Route(\"api/[controller]\")] public class WeatherController : ControllerBase { private readonly IRateLimiter _rateLimiter; public WeatherController(IRateLimiter rateLimiter) { _rateLimiter = rateLimiter; } [HttpGet] public async Task<IActionResult> GetWeather() { if (!await _rateLimiter.TryConsumeAsync()) { return StatusCode(429, new { error = \"Rate limit exceeded. Please try again later.\" }); } // Your API logic here return Ok(new { temperature = 22, condition = \"Sunny\" }); } } Middleware Integration public class RateLimitingMiddleware { private readonly RequestDelegate _next; private readonly IRateLimiter _rateLimiter; public RateLimitingMiddleware(RequestDelegate next, IRateLimiter rateLimiter) { _next = next; _rateLimiter = rateLimiter; } public async Task InvokeAsync(HttpContext context) { if (!await _rateLimiter.TryConsumeAsync()) { context.Response.StatusCode = 429; await context.Response.WriteAsync(\"Rate limit exceeded\"); return; } await _next(context); } } // In Startup.cs or Program.cs app.UseMiddleware<RateLimitingMiddleware>(); Advanced Scenarios Per-User Rate Limiting public class UserRateLimitingService { private readonly IServiceProvider _serviceProvider; private readonly ConcurrentDictionary<string, IRateLimiter> _userLimiters; public UserRateLimitingService(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; _userLimiters = new ConcurrentDictionary<string, IRateLimiter>(); } public async Task<bool> TryConsumeAsync(string userId) { var limiter = _userLimiters.GetOrAdd(userId, _ => _serviceProvider.GetRequiredService<IRateLimiter>()); return await limiter.TryConsumeAsync(); } } Different Limits for Different Operations // Configure multiple rate limiters services.Configure<RateLimiterOptions>(\"ReadOperations\", options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 1000; options.RefillRate = 100; options.RefillPeriod = TimeSpan.FromSeconds(1); }); services.Configure<RateLimiterOptions>(\"WriteOperations\", options => { options.Algorithm = RateLimitingAlgorithm.FixedWindow; options.Capacity = 10; options.WindowSize = TimeSpan.FromMinutes(1); }); // Use in your service public class DataService { private readonly IRateLimiter _readLimiter; private readonly IRateLimiter _writeLimiter; public DataService(IOptionsSnapshot<RateLimiterOptions> options) { _readLimiter = new TokenBucketStrategy( Options.Create(options.Get(\"ReadOperations\"))); _writeLimiter = new FixedWindowStrategy( Options.Create(options.Get(\"WriteOperations\"))); } public async Task<Data> ReadDataAsync() { if (!await _readLimiter.TryConsumeAsync()) { throw new RateLimitExceededException(\"Read rate limit exceeded\"); } // Read logic here return new Data(); } public async Task WriteDataAsync(Data data) { if (!await _writeLimiter.TryConsumeAsync()) { throw new RateLimitExceededException(\"Write rate limit exceeded\"); } // Write logic here } } Graceful Degradation public class ResilientService { private readonly IRateLimiter _rateLimiter; public ResilientService(IRateLimiter rateLimiter) { _rateLimiter = rateLimiter; } public async Task<string> ProcessRequestAsync() { if (await _rateLimiter.TryConsumeAsync()) { // Full processing return await PerformFullProcessingAsync(); } // Check if we can wait a bit var waitTime = await _rateLimiter.GetWaitTimeAsync(); if (waitTime < TimeSpan.FromMilliseconds(100)) { await Task.Delay(waitTime); return await PerformFullProcessingAsync(); } // Fallback to cached or simplified response return GetCachedResponse(); } private async Task<string> PerformFullProcessingAsync() { // Expensive operation await Task.Delay(50); return \"Full result\"; } private string GetCachedResponse() { return \"Cached result\"; } } Distributed Rate Limiting with Redis // Configure distributed cache services.AddStackExchangeRedisCache(options => { options.Configuration = \"localhost:6379\"; }); // Configure distributed rate limiting services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 1000; options.RefillRate = 100; options.RefillPeriod = TimeSpan.FromSeconds(1); options.DistributedCacheKey = \"MyApp:GlobalRateLimit\"; }); // The rate limiter will automatically use Redis for state storage services.AddRateLimiter(); Testing Your Rate Limiter [Test] public async Task ShouldRespectRateLimit() { // Arrange var options = Options.Create(new RateLimiterOptions { Algorithm = RateLimitingAlgorithm.TokenBucket, Capacity = 5, RefillRate = 1, RefillPeriod = TimeSpan.FromSeconds(1) }); var rateLimiter = new TokenBucketStrategy(options); // Act & Assert // Should allow first 5 requests for (int i = 0; i < 5; i++) { Assert.IsTrue(await rateLimiter.TryConsumeAsync()); } // Should deny the 6th request Assert.IsFalse(await rateLimiter.TryConsumeAsync()); // Wait for refill and try again await Task.Delay(TimeSpan.FromSeconds(1.1)); Assert.IsTrue(await rateLimiter.TryConsumeAsync()); } Error Handling public async Task<IActionResult> HandleRequestAsync() { try { var waitTime = await _rateLimiter.GetWaitTimeAsync(); if (waitTime > TimeSpan.Zero) { Response.Headers.Add(\"Retry-After\", waitTime.TotalSeconds.ToString()); return StatusCode(429, new { error = \"Rate limit exceeded\", retryAfter = waitTime.TotalSeconds }); } if (!await _rateLimiter.TryConsumeAsync()) { return StatusCode(429, \"Rate limit exceeded\"); } // Process request return Ok(await ProcessRequestAsync()); } catch (Exception ex) { // Log error and provide fallback _logger.LogError(ex, \"Rate limiter error\"); return StatusCode(500, \"Internal server error\"); } }"
  },
  "index.html": {
    "href": "index.html",
    "title": "RateLimiter Library Documentation | RateLimiter Library Documentation",
    "summary": "RateLimiter Library Documentation Welcome to the comprehensive documentation for the RateLimiter library - a high-performance, thread-safe rate limiting solution for .NET applications. Overview The RateLimiter library provides multiple rate limiting algorithms implemented using the Strategy and Adapter design patterns. It's designed for Shopify pair programming interviews and demonstrates professional-grade software architecture and engineering practices. Key Features Multiple Algorithms: Token Bucket, Fixed Window, and Sliding Window rate limiting strategies Thread-Safe: All implementations are designed for concurrent access Dependency Injection: Full support for Microsoft.Extensions.DependencyInjection Configuration: Flexible configuration using the Options pattern Async/Await: Modern async programming patterns throughout High Performance: Optimized for minimal memory allocations and high throughput Supported Rate Limiting Algorithms Token Bucket Allows burst traffic up to a configured capacity while maintaining a steady refill rate. Ideal for scenarios where occasional bursts are acceptable. Fixed Window Counts requests within fixed time windows. Simple and memory-efficient, but can allow burst traffic at window boundaries. Sliding Window Provides smooth rate limiting by maintaining a rolling window of request timestamps. More accurate than fixed window but uses more memory. Quick Start // Basic usage with dependency injection services.Configure<RateLimiterOptions>(options => { options.Algorithm = RateLimitingAlgorithm.TokenBucket; options.Capacity = 100; options.RefillRate = 10; options.RefillPeriod = TimeSpan.FromSeconds(1); }); services.AddRateLimiter(); // Use in your service public class MyService { private readonly IRateLimiter _rateLimiter; public MyService(IRateLimiter rateLimiter) { _rateLimiter = rateLimiter; } public async Task<bool> ProcessRequestAsync() { if (await _rateLimiter.TryConsumeAsync()) { // Process the request return true; } // Rate limit exceeded return false; } } Architecture The library is built using several design patterns: Strategy Pattern: Allows switching between rate limiting algorithms at runtime Adapter Pattern: Provides backward compatibility with legacy interfaces Factory Pattern: Creates appropriate rate limiter instances based on configuration Options Pattern: Manages configuration through IOptions Getting Started Installation and Setup - Learn how to install and configure the library Configuration Guide - Understand all configuration options Usage Examples - See practical examples for different scenarios Performance Considerations - Optimize for your use case API Reference - Detailed API documentation Contributing This project demonstrates best practices for: Clean architecture and SOLID principles Comprehensive unit testing with high coverage Thread-safe concurrent programming Modern C# and .NET features Professional documentation Support For questions, issues, or contributions, please refer to the project repository and documentation."
  }
}